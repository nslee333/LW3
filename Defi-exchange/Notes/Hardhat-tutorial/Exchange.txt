These are my notes about the Exchange.sol contract.

This exchange is a working version of the Uniswap V1 AMM model.

At the core of the Uniswap V1 AMM model, there is the x*y=k formula.

This formula helps calculate how much of one token will be received for another token.

x*y=k

Let's say that x stands for ether, and y stands for bitcoin, when both are multiplied, you get K which is a constant product.

No matter how much ether and bitcoin are exchanged, the formula constant K will still equal the same amount regardless of which reserve gets depleted more.

Let's put that into a formula.

(X + XΔ) * (Y - YΔ) = K

Where Δ stands for change in reserve amounts after a swap, the formula will always equal the contant K.

If we were to create a function that would calculate the value of a bitcoin to ether swap, we would manipulate the formula a bit (solve for x) to help calculate the value automatically.

YΔ = (Y * XΔ) / (X + XΔ) // Everything makes sense except for the Y * XΔ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

This will all come in handy understanding the Exchange.sol contract.

--------------------------------------------------------------------------------------------------------------------------------------------------

contract Exchange is ERC20 {

    
    address public cryptoDevTokenAddress; 1.
    

    constructor(address _cryptoDevToken) ERC20 ("CryptoDev LP Token", "CDLP") { 2
        require(_cryptoDevToken != address(0), "Token address passed is a null address");
        cryptoDevTokenAddress = _cryptoDevToken; 
    }

    function getReserve() public view returns (uint) { 3
        return ERC20(cryptoDevTokenAddress).balanceOf(address(this)); // Goes to the mapping in the CryptoDevToken contract, and gets how much tokens this address owns.
    }
------------------------------------------------------------------------------------------------------------------------------------------------

1. This is the a state variable for the Token Address that we will be our second token which we will exchange for ether.
2. This constructor is taking in.
    1. The address of the CDT contract, as an argument, and also initializing the ERC20 contract's constructor with The name of the token and the symbol of the token.
        - The constructor is requiring that the address provided is not a null address, and throws an error if it is null.
        - It Initializes the state variable 'cryptoDevTokenAddress' with the constuctor argument passed in at deployment. 
3. This function is used to get the Total Supply of CDT tokens that the exchange owns.
    - Specifically it calls the CDT contract's 'balanceOf' function which is declared in the OZ ERC20 contract.
        - balanceOf goes to the OZ ERC20 contract, then goes to an internal mapping, and grabs the balance of the address and returns it to the function that called it.
        - Gets the balance of CDTs that exchange owns, and returns the value to the getReserve function call.
    - The 'ERC20(cryptoDevTokenAddress)' is creating an instance of the contract for our use in our contract without creating an interface.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function addLiquidity(uint _amount) public payable returns (uint) { 1
    uint liquidity; 
    uint ethBalance = address(this).balance;
    uint cryptoDevTokenReserve = getReserve();
    ERC20 cryptoDevToken = ERC20(cryptoDevTokenAddress); // ERC20 is a data type, and it's creating an instance of the address? not sure.
    
    
    if(cryptoDevTokenReserve == 0) {

        cryptoDevToken.transferFrom(msg.sender, address(this), _amount);

        liquidity = ethBalance;
        _mint(msg.sender, liquidity);
    // If this is the initial adding of funds, then it transfer the funds, then it mints the amount of LP tokens that is the exact same as the amount of eth deposiited.
    } else {
        uint ethReserve = ethBalance - msg.value;

        uint cryptoDevTokenAmount = (msg.value * cryptoDevTokenReserve)/(ethReserve); // Come back to this later. 
        require(_amount >= cryptoDevTokenAmount, "Amount Of tokens sent is less than the minimum tokens required."); 
        cryptoDevToken.transferFrom(msg.sender, address(this), cryptoDevTokenAmount);
        liquidity = (totalSupply() * msg.value/ ethReserve)/ ethReserve;
        _mint(msg.sender, liquidity);
    } 
    // Else, Check that the amount of ether sent is correct, and then transfer the ether, then mint LP tokens according to the liquidity provided.

    // Summary, 
    return liquidity;
}

------------------------------------------------------------------------------------------------------------------------------------------------

This function is used to add liquidity to the exchange.

It takes in a _amount as an argument, and it has a conditional that checks if there is any CDTs in exchange's reserves. 
    1. If CDT reserves are zero, then it transfers the CDTs from the liquidity provider's address to the exchange, according to the amount argument. With no requirements.
        - Then it mints the Liquidity Provider Tokens to the User. 
        - This is the initialization of the exchange, the first user sets the price, all liquidity added afterwards must follow the same ratio set by the initialization.
    2. Else, Check and make sure that the ether provided is correct (according to the ratio) 
        - then transfer the CDTs from the LP's address to the exchange, along with the Ether sent to the exchange contract.
        - Then according to the ratio 

